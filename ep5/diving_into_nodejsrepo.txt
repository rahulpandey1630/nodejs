// âœ… When we use require('./xyz.js'), Node.js does NOT just read the file directly.
// ğŸ”„ Node wraps the code inside xyz.js in a function like this:
(function (exports, require, module, __filename, __dirname) {
    // Contents of xyz.js go here
});

// ğŸ“¦ Purpose of wrapping:
// - Provides local scope (avoids polluting global scope)
// - Gives access to useful variables automatically

// ğŸ“Œ Variables provided:
// - exports: object to export things from this module
// - require: function to import other modules
// - module: holds metadata and the exports object
// - __filename: full path of the current file
// - __dirname: path of the directory containing the file

// ğŸ§  This is how CommonJS module system works internally in Node.js

// âœ… So, require('./xyz.js') â†’ actually loads and executes the wrapped function
// âœ… Returns module.exports from xyz.js





// âœ… In Node.js, when you use require('./xyz.js'), it doesn't just read the file directly.
// ğŸ”’ Instead, Node wraps the entire content of xyz.js in a function â€” this function is an IIFE.

// âœ… IIFE = Immediately Invoked Function Expression
// ğŸ§  It's a JavaScript function that runs as soon as it is defined.

// ğŸ“¦ Node wraps the module code like this:

(function (exports, require, module, __filename, __dirname) {
    // ğŸ“„ All code written in xyz.js is placed here

    // âœ… This function is called immediately by Node.js (IIFE)
})();

// ğŸ”„ This makes every file in Node a separate module with its own scope
// ğŸ” Avoids polluting the global scope and enables modular structure

// âœ… So, require('./xyz.js') actually loads and runs the IIFE-wrapped module,
// âœ… and returns module.exports from inside that function.



//require("/path");
// All the code of the module is wrapped inside the function (IIFE)
//IIFE - Imediately Invoked Function Expression

(function () {
  // aAl modules are converted like this before executing 
  // All the code of the module is runs here

})();



// Q: How are variables & functions kept private in different modules?

// A: Using IIFE (Immediately Invoked Function Expression) and require() statement

// - IIFE provides a **wrapping scope**
// - This wrapping scope keeps variables/functions **encapsulated**
// - require() is used to **import/export modules**, maintaining modular boundaries


 

 //How do you get access to module, require, etc. in Node.js?
 // âœ… Node.js wraps every module (file) inside a function
//    This function is called an IIFE (Immediately Invoked Function Expression)

// âœ… Syntax of internal wrapper used by Node.js:
(function(exports, require, module, __filename, __dirname) {
    // ğŸ‘‰ Your module code lives here
});

// âœ… Because of this, every file gets access to:
//    â†’ require     â†’ used to import other modules
//    â†’ module      â†’ contains info about current module
//    â†’ exports     â†’ used to export functions/objects
//    â†’ __filename  â†’ full path of current file
//    â†’ __dirname   â†’ directory name of current file

// âœ… Purpose of the wrapper function:
//    â†’ Provides private scope (avoids global variable conflict)
//    â†’ Allows modularity and export/import features
//    â†’ Enables efficient execution and debugging

// âœ… This pattern is part of the CommonJS module system in Node.js


  
// the internal working of require(path) in Node.js.

// âœ… require(path) â€“ Node.js module loading system (CommonJS)

// 1. Resolving the Module
//    â†’ Converts the path into an absolute path
//    â†’ Supports local files (./ or ../), .json, or core modules (like 'fs', 'http', etc.)

// 2. Loading the Module
//    â†’ Reads the file content based on the file type
//    â†’ .js â†’ loaded as JavaScript
//    â†’ .json â†’ parsed as JSON

// 3. Wrapping Inside IIFE
//    â†’ The code is wrapped in a function by Node.js:
//      (function(exports, require, module, __filename, __dirname) { ... });
//    â†’ This creates a private scope for the module

// 4. Evaluation
//    â†’ The wrapped function is executed
//    â†’ The result is assigned to module.exports

// 5. Caching
//    â†’ Once a module is loaded, it is cached
//    â†’ Future require calls return the cached version to improve performance


//wrapped inside  iife then passed to V8




// libuv is a multi-platform C library used by Node.js.
// It provides an event-driven, asynchronous I/O model.

// ğŸ” Event Loop:
// libuv implements the event loop that keeps Node.js non-blocking.
// It listens for events (I/O, timers, etc.) and executes callbacks.

// ğŸ§µ Thread Pool:
// libuv has a thread pool to handle blocking operations (like fs or DNS).
// Default size is 4 threads. Can be changed with UV_THREADPOOL_SIZE.

// ğŸŒ Cross-platform I/O:
// On Linux, it uses epoll.
// On macOS/BSD, it uses kqueue.
// On Windows, it uses IOCP.

// ğŸ”§ libuv handles:
// - File system operations (fs)
// - Network (TCP, UDP)
// - DNS lookups
// - Timers
// - Signal handling
// - Child processes
// - Thread pool tasks

// ğŸ“¦ Architecture:
// JS Code â†’ Node.js C++ â†’ libuv â†’ OS I/O APIs

// âœ… Importance:
// Makes Node.js fast, asynchronous, and scalable
// Abstracts OS-specific I/O so developers write consistent async JS code
